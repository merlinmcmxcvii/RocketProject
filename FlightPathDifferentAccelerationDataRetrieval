##DATA RETRIEVAL
## MODULES ET CETERA
print(__file__)
import numpy
import pylab
from datetime import datetime
import os
script_dir = os.path.dirname(os.path.abspath(__file__))
dest_dir = os.path.join(script_dir, 'data')
try:
    os.makedirs(dest_dir)
except OSError:
    pass 
pylab.clf() 
timestamp = datetime.now().strftime("%Y%m%d-%H%M%S") 
now = datetime.now()
print("Model started running at %s:%s:%s on %s/%s/%s" % (now.hour, now.minute, now.second, now.day, now.month, now.year))

## PARAMETERS
# First, all the normal parameters:
g = 9.81 # (m/s^2)          # roughly constant acceleration due to gravity on earth's surface
duration = 5 # (s)          # total time for simulation
z0 = 0 # (m)                # initial height
v0 = 0 # (m/s)              # initial velocity (vertical direction)
t0 = 0 # (s)                # starting time
massr = 0.289 # (kg)        # mass rocket
rhow = 1000 # (kg/m^3)      # density water
rhoa = 1.225 # (kg/m^3)     # density of air
vrel0 = 0 # (m/s)           # initial vrel
P0 =  101325 # (Pa)         # normal atmospheric pressure

# Second, all the 'fitting' parameters, parameters that might change
# after the actual testing of the rocket.
Cd = 0.9 # (dimensionless)  # drag coefficient
dt = 0.00001 # (s)          # time step
massw0 = 0.541 # (kg)       # initial mass of water inside the bottle
Ab = 0.0014522 # (m^3)      # area of the bottlecap (r \approx 0.0125)
Area = 0.019113 # (m^3)     # (initial) area of the water level and the crossectional area of the rocket. r = 0.06
NkBT = 101.35 # (m^3*Pa)       # constant factor of the number of molecules of air inside the rocket, the Boltzman constant and the temperature of the air
Vbottle = 0.001 #(m^3)      # total volume of the bottle
#hr = 0.15 # (m)            # height of the rod inside the bottle. 


## Text file with all the parameters
parameters = g, Cd, dt, duration, z0, v0, t0, massr, rhow, massw0, rhoa, Ab, Area,  vrel0, NkBT, P0, Vbottle
path_parameters = os.path.join(dest_dir + 'parameters_used.txt' + timestamp)  
numpy.savetxt(path_parameters, parameters, header='g, Cd, dt, duration, z0, v0, t0, massr, rhow, massw0, rhoa, Ab, Area, vrel0, NkBT, P0, Vbottle,  : All dimensions SI units !')


## FUNCTIONS
timesteps = numpy.int(duration/dt)              
time = numpy.arange(timesteps+1,dtype='d')*dt 
mass = numpy.zeros(timesteps+1,dtype='d')
a = numpy.zeros(timesteps+1,dtype='d')
F = numpy.zeros(timesteps+1,dtype='d')
v = numpy.zeros(timesteps+1,dtype='d')
z = numpy.zeros(timesteps+1,dtype='d')
t = numpy.zeros(timesteps+1,dtype='d')
beta = numpy.zeros(timesteps+1,dtype='d')   # beta is dm/dt
Vair = numpy.zeros(timesteps+1,dtype='d')
Pair = numpy.zeros(timesteps+1,dtype='d')
vrel = numpy.zeros(timesteps+1,dtype='d')
massw = numpy.zeros(timesteps+1,dtype='d')
Vw = numpy.zeros(timesteps+1,dtype='d')
h = numpy.zeros(timesteps+1,dtype='d')
Fthrust = numpy.zeros(timesteps+1,dtype='d')


## STARTING VALUES OF THE FUNCTIONS
mass[0] = massr + massw0
F[0] = - mass[0]*g - 0.5*rhoa*Cd*Area*v[0]*abs(v[0]) + vrel[0]*beta[0] 
a[0] = F[0]/mass[0]
v[0] = v0
z[0] = z0
t[0] = t0
vrel[0] = vrel0 # 0
beta[0] = Ab*rhow*vrel[0] # 0
massw[0] = massw0 
Vw[0] = massw[0]/rhow 
Vair[0] = Vbottle - Vw[0]
Pair[0] = NkBT/Vair[0]
h[0] = Vw[0]/Area
Fthrust[0] = vrel[0]*beta[0]
maxz = 0
maxv = 0
maxa = 0


## ACTUAL FORMULAS
for j in numpy.arange(timesteps) :
    if massw[j] > 0:                # This if-loop calculates the thrust force of the water on the rocket.    
        Vw[j] = massw[j]/rhow
        Vair[j] = Vbottle - Vw[j]
        Pair[j] = NkBT/Vair[j]
        h[j] = Vw[j]/Area   
        vrel[j] = (2* (Pair[j]-P0 + (g+a[j])*rhow*h[j]) / (rhow*(1-(Ab**2) / (Area**2) )))**0.5 # Derived using Bernoulli's equation and the equation of continuity.
        beta[j] = Ab*rhow*vrel[j]
        mass[j] = mass[j] - beta[j]*dt + massr
        Fthrust[j] = vrel[j]*beta[j]
    else:                           # If all the water is out of the rocket (massw == 0), this loop 
        mass[j] = massr
        Fthrust[j] = 0
    F[j] = - mass[j]*g - 0.5*rhoa*Cd*Area*v[j]*abs(v[j]) + Fthrust[j]  
    a[j] = F[j]/mass[j]
    v[j+1] = v[j] + dt*a[j]   
    z[j+1] = z[j] + dt*v[j+1] + dt*dt*a[j]/2
    t[j+1] = t[j] + dt
    massw[j+1] = massw[j] - beta[j]*dt
    if j==timesteps :               # This if-loop breaks the for-loop if the experiment time has ended.
        break
    elif z[j] < 0 and j > 0:        # This elif-loop lets a, v, and x go to 0 if the rocket hits the ground. (inelastic collision)
        a[j] = 0
        v[j] = 0
        z[j] = 0
    if z[j+1] > maxz:                # Saves the maximum z value
        maxz = z[j+1]
    if v[j+1] > maxv:                # Saves the maximum v value
        maxv = v[j+1]
    if a[j] > maxa:                  # Saves the maximum a value
        maxa =  a[j]     


## Print the maximum values for the height, velocity and acceleration:
print (" ")
print ("Maximum height: " + str(round(maxz, 2)) + " (m)")
print ("Maximum velocity: " + str(round(maxv, 2)) + " (m/s)")
print ("Maximum acceleration: " + str(round(maxa, 2)) + " (m/s^2)")
print (" ")

## prints the last array position calculated:
print("Last array position calculated = " + str(j))
print (" ")


## DATA RETRIEVAL
filename = raw_input('Please type in the name of the data file you wish to use:  ')
if filename[-4:] != '.txt' :
  print('\n You forgot to include the .txt file extension in your filename!  \n But, don\'t worry, the program was written to automatically add it ;) \n')
  filename += '.txt'

f = open(filename, 'r')

header1 = f.readline()

x = []
y = []
z = []


for line in f:
    if line[0][0].isdigit():     
      columns = line.split()
      x.append(int(columns[2].strip(",")))  
      y.append(int(columns[3].strip(",")))
      z.append(int(columns[4]))
    else:
      print(' There is a blackout after the '+ str(len(x)) +'th data point')
#      break     


f.close()

print('\n Your data file included '+ str(len(x)) +' timestamps,') 
print(' which at 100Hz data rate is about '+ str((len(x))/100) +' seconds of measuring time.') 

data_rate_string = raw_input('Please type in the data rate that your accelerometer used (either 100 Hz or 200 Hz):     ')
datarate = 100*int(data_rate_string[0])

time = numpy.arange(len(x), dtype='d') / datarate 

acc_vectors = [numpy.array(x,dtype='i'), numpy.array(y,dtype='i'), numpy.array(z,dtype='i')]  
xx = numpy.array(x,dtype='i')
yy = numpy.array(y,dtype='i')
zz = numpy.array(z,dtype='i')

## DATA MODIFIYNG
dt2 = 1/200

timesteps2 = numpy.int(len(z))              
zreal = numpy.arange(timesteps2+1,dtype='d')             
time2 = numpy.arange(timesteps2+1,dtype='d')*dt2

for i in numpy.arange(timesteps2):
    zreal[i] = (zz[i] + 3.114)/(3.297) 

##PLOTS
z.resize(j+1)
v.resize(j+1)
a.resize(j+1)
time.resize(j+1)

# Height subplot
ax1=pylab.subplot(3,1,1)
pylab.plot(time,z,'kx')
pylab.plot(time2, zreal, 'kx')
pylab.xlabel('time (s)')
pylab.ylabel('height (m)')

# Velocity subplot
ax2=pylab.subplot(3,1,2)
pylab.plot(time,v,'kx')
pylab.xlabel('time (s)')
pylab.ylabel('velocity (m/s)')

# Acceleration subplot
ax3=pylab.subplot(3,1,3)
pylab.plot(time,a,'kx')
pylab.xlabel('time (s)')
pylab.ylabel('acceleration (m/s$^2$)')

# Saves plots
path_figures = os.path.join(dest_dir, timestamp + 'FlightPath.png')
pylab.savefig(path_figures)
pylab.show()

dataarray = numpy.array([time, z, v, a]).T            
path_dataarray = os.path.join(dest_dir, timestamp + 'data_array.txt')
numpy.savetxt(path_dataarray, dataarray, header='time, z, v, a')
